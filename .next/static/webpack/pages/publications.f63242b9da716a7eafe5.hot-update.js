"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/publications",{

/***/ "./components/publicationList.js":
/*!***************************************!*\
  !*** ./components/publicationList.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* module decorator */ module = __webpack_require__.hmd(module);\nvar publicationList = [{\n  year: '2021',\n  title: \" INTERCAAT: identifying interface residues between macromolecules\",\n  authors: \"Steven Grudman, J Eduardo Fajardo, Andras Fiser\",\n  abstarct: \" Summary: The Interface Contact definition with Adaptable Atom Types (INTERCAAT) was developed to determine the atomic interactions between molecules that form a known three dimensional structure. First, INTERCAAT creates a Voronoi tessellation where each atom acts as a seed. Interactions are defined by atoms that share a hyperplane and whose distance is less than the sum of each atoms' Van der Waals radii plus the diameter of a solvent molecule. Interacting atoms are then classified and interactions are filtered based on compatibility. INTERCAAT implements an adaptive atom classification method; therefore, it can explore interfaces between a variety macromolecules.\",\n  link: \"https://pubmed.ncbi.nlm.nih.gov/34499117/\",\n  thumbnail: \"https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/bioinformatics/PAP/10.1093_bioinformatics_btab596/2/m_btab596f1.jpeg?Expires=1638445955&Signature=IvVpnKCut9m5I-B0ysJfhAVnuwgIB9p0sr2x80nzyKpC43Agdlh8~HwIq9B2ZYp7ApjOBFEcthLwIHCdGhLG6wMp8DgagyYioDFTz1l2iE5LdeKdaZj0Aheb23SMjc1WLpF-vXIY~7WCzxgt57owdjnQMztwahIqvQnXFEwffVqR848gAZYuz3dILbTQexeqYjUE~AJvdnU7jFPO~Z8YAcw9TxS-D-pfKQepX-ZVe2Mnfu8bw3yIJbIp66yMNQybdj5IHEUewDzEo4M2C7cko0crj58pZhho7BVmtO1OduvaI-NHn3CD39ujUct-cXBagyoy0Kp6PMPvm9tR6xpGGg__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA\"\n}, {\n  year: '2021',\n  title: \" Estimating the accuracy of pharmacophore-based detection of cognate receptor-ligand pairs in the immunoglobulin superfamily \",\n  authors: \"Nelson Gil, Rojan Shrestha, Andras Fiser\",\n  abstarct: \"Secreted and membrane-bound members of the immunoglobulin superfamily (IgSF) encompass a large, diverse array of proteins that play central roles in immune response and neural development, and are implicated in diseases ranging from cancer to rheumatoid arthritis. Despite the potential biomedical benefits of understanding IgSF:IgSF cognate receptor-ligand interactions, relatively little about them is known at a molecular level, and experimentally probing all possible receptor-ligand pairs is prohibitively costly. The Protein Ligand Interface Design (ProtLID) algorithm is a computational pharmacophore-based approach to identify cognate receptor-ligand pairs that was recently validated in a pilot study on a small set of IgSF complexes. Although ProtLID has shown a success rate of 61% at identifying at least one cognate ligand for a given receptor, it currently lacks any form of confidence measure that can prioritize individual receptor-ligand predictions to pursue experimentally. In this study, we expanded the application of ProtLID to cover all IgSF complexes with available structural data. In addition, we introduced an approach to estimate the confidence of predictions made by ProtLID based on a statistical analysis of how the ProtLID-constructed pharmacophore matches the structures of candidate ligands. The confidence score combines the physicochemical compatibility, spatial consistency, and mathematical skewness of the distribution of matches throughout a set of candidate ligands. Our results suggest that a subset of cases meeting stringent confidence criteria will always have at least one successful receptor-ligand prediction. \",\n  link: \"https://pubmed.ncbi.nlm.nih.gov/33483991/\",\n  thumbnail: \"\"\n}];\n/* harmony default export */ __webpack_exports__[\"default\"] = (publicationList);\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3B1YmxpY2F0aW9uTGlzdC5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBLElBQU1BLGVBQWUsR0FBRyxDQUNwQjtBQUNJQyxFQUFBQSxJQUFJLEVBQUUsTUFEVjtBQUVJQyxFQUFBQSxLQUFLLEVBQUUsbUVBRlg7QUFHSUMsRUFBQUEsT0FBTyxFQUFDLGlEQUhaO0FBSUlDLEVBQUFBLFFBQVEsRUFBQyxvcUJBSmI7QUFLSUMsRUFBQUEsSUFBSSxFQUFFLDJDQUxWO0FBTUlDLEVBQUFBLFNBQVMsRUFBQztBQU5kLENBRG9CLEVBU3BCO0FBQ0lMLEVBQUFBLElBQUksRUFBRSxNQURWO0FBRUlDLEVBQUFBLEtBQUssRUFBRSwrSEFGWDtBQUdJQyxFQUFBQSxPQUFPLEVBQUMsMENBSFo7QUFJSUMsRUFBQUEsUUFBUSxFQUFDLDRuREFKYjtBQUtJQyxFQUFBQSxJQUFJLEVBQUUsMkNBTFY7QUFNSUMsRUFBQUEsU0FBUyxFQUFDO0FBTmQsQ0FUb0IsQ0FBeEI7QUFvQkEsK0RBQWVOLGVBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9wdWJsaWNhdGlvbkxpc3QuanM/NDlkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwdWJsaWNhdGlvbkxpc3QgPSBbXG4gICAge1xuICAgICAgICB5ZWFyOiAnMjAyMScsXG4gICAgICAgIHRpdGxlOiBcIiBJTlRFUkNBQVQ6IGlkZW50aWZ5aW5nIGludGVyZmFjZSByZXNpZHVlcyBiZXR3ZWVuIG1hY3JvbW9sZWN1bGVzXCIsXG4gICAgICAgIGF1dGhvcnM6XCJTdGV2ZW4gR3J1ZG1hbiwgSiBFZHVhcmRvIEZhamFyZG8sIEFuZHJhcyBGaXNlclwiLFxuICAgICAgICBhYnN0YXJjdDpcIiBTdW1tYXJ5OiBUaGUgSW50ZXJmYWNlIENvbnRhY3QgZGVmaW5pdGlvbiB3aXRoIEFkYXB0YWJsZSBBdG9tIFR5cGVzIChJTlRFUkNBQVQpIHdhcyBkZXZlbG9wZWQgdG8gZGV0ZXJtaW5lIHRoZSBhdG9taWMgaW50ZXJhY3Rpb25zIGJldHdlZW4gbW9sZWN1bGVzIHRoYXQgZm9ybSBhIGtub3duIHRocmVlIGRpbWVuc2lvbmFsIHN0cnVjdHVyZS4gRmlyc3QsIElOVEVSQ0FBVCBjcmVhdGVzIGEgVm9yb25vaSB0ZXNzZWxsYXRpb24gd2hlcmUgZWFjaCBhdG9tIGFjdHMgYXMgYSBzZWVkLiBJbnRlcmFjdGlvbnMgYXJlIGRlZmluZWQgYnkgYXRvbXMgdGhhdCBzaGFyZSBhIGh5cGVycGxhbmUgYW5kIHdob3NlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgc3VtIG9mIGVhY2ggYXRvbXMnIFZhbiBkZXIgV2FhbHMgcmFkaWkgcGx1cyB0aGUgZGlhbWV0ZXIgb2YgYSBzb2x2ZW50IG1vbGVjdWxlLiBJbnRlcmFjdGluZyBhdG9tcyBhcmUgdGhlbiBjbGFzc2lmaWVkIGFuZCBpbnRlcmFjdGlvbnMgYXJlIGZpbHRlcmVkIGJhc2VkIG9uIGNvbXBhdGliaWxpdHkuIElOVEVSQ0FBVCBpbXBsZW1lbnRzIGFuIGFkYXB0aXZlIGF0b20gY2xhc3NpZmljYXRpb24gbWV0aG9kOyB0aGVyZWZvcmUsIGl0IGNhbiBleHBsb3JlIGludGVyZmFjZXMgYmV0d2VlbiBhIHZhcmlldHkgbWFjcm9tb2xlY3VsZXMuXCIsXG4gICAgICAgIGxpbms6IFwiaHR0cHM6Ly9wdWJtZWQubmNiaS5ubG0ubmloLmdvdi8zNDQ5OTExNy9cIixcbiAgICAgICAgdGh1bWJuYWlsOlwiaHR0cHM6Ly9vdXAuc2lsdmVyY2hhaXItY2RuLmNvbS9vdXAvYmFja2ZpbGUvQ29udGVudF9wdWJsaWMvSm91cm5hbC9iaW9pbmZvcm1hdGljcy9QQVAvMTAuMTA5M19iaW9pbmZvcm1hdGljc19idGFiNTk2LzIvbV9idGFiNTk2ZjEuanBlZz9FeHBpcmVzPTE2Mzg0NDU5NTUmU2lnbmF0dXJlPUl2VnBuS0N1dDltNUktQjB5c0pmaEFWbnV3Z0lCOXAwc3IyeDgwbnp5S3BDNDNBZ2RsaDh+SHdJcTlCMlpZcDdBcGpPQkZFY3RoTHdJSENkR2hMRzZ3TXA4RGdhZ3lZaW9ERlR6MWwyaUU1TGRlS2RhWmowQWhlYjIzU01qYzFXTHBGLXZYSVl+N1dDenhndDU3b3dkam5RTXp0d2FoSXF2UW5YRkV3ZmZWcVI4NDhnQVpZdXozZElMYlRRZXhlcVlqVUV+QUp2ZG5VN2pGUE9+WjhZQWN3OVR4Uy1ELXBmS1FlcFgtWlZlMk1uZnU4YnczeUlKYklwNjZ5TU5ReWJkajVJSEVVZXdEekVvNE0yQzdja28wY3JqNThwWmhobzdCVm10TzFPZHV2YUktTkhuM0NEMzl1alVjdC1jWEJhZ3lveTBLcDZQTVB2bTl0UjZ4cEdHZ19fJktleS1QYWlyLUlkPUFQS0FJRTVHNUNSREs2UkQzUEdBXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogJzIwMjEnLFxuICAgICAgICB0aXRsZTogXCIgRXN0aW1hdGluZyB0aGUgYWNjdXJhY3kgb2YgcGhhcm1hY29waG9yZS1iYXNlZCBkZXRlY3Rpb24gb2YgY29nbmF0ZSByZWNlcHRvci1saWdhbmQgcGFpcnMgaW4gdGhlIGltbXVub2dsb2J1bGluIHN1cGVyZmFtaWx5IFwiLFxuICAgICAgICBhdXRob3JzOlwiTmVsc29uIEdpbCwgUm9qYW4gU2hyZXN0aGEsIEFuZHJhcyBGaXNlclwiLFxuICAgICAgICBhYnN0YXJjdDpcIlNlY3JldGVkIGFuZCBtZW1icmFuZS1ib3VuZCBtZW1iZXJzIG9mIHRoZSBpbW11bm9nbG9idWxpbiBzdXBlcmZhbWlseSAoSWdTRikgZW5jb21wYXNzIGEgbGFyZ2UsIGRpdmVyc2UgYXJyYXkgb2YgcHJvdGVpbnMgdGhhdCBwbGF5IGNlbnRyYWwgcm9sZXMgaW4gaW1tdW5lIHJlc3BvbnNlIGFuZCBuZXVyYWwgZGV2ZWxvcG1lbnQsIGFuZCBhcmUgaW1wbGljYXRlZCBpbiBkaXNlYXNlcyByYW5naW5nIGZyb20gY2FuY2VyIHRvIHJoZXVtYXRvaWQgYXJ0aHJpdGlzLiBEZXNwaXRlIHRoZSBwb3RlbnRpYWwgYmlvbWVkaWNhbCBiZW5lZml0cyBvZiB1bmRlcnN0YW5kaW5nIElnU0Y6SWdTRiBjb2duYXRlIHJlY2VwdG9yLWxpZ2FuZCBpbnRlcmFjdGlvbnMsIHJlbGF0aXZlbHkgbGl0dGxlIGFib3V0IHRoZW0gaXMga25vd24gYXQgYSBtb2xlY3VsYXIgbGV2ZWwsIGFuZCBleHBlcmltZW50YWxseSBwcm9iaW5nIGFsbCBwb3NzaWJsZSByZWNlcHRvci1saWdhbmQgcGFpcnMgaXMgcHJvaGliaXRpdmVseSBjb3N0bHkuIFRoZSBQcm90ZWluIExpZ2FuZCBJbnRlcmZhY2UgRGVzaWduIChQcm90TElEKSBhbGdvcml0aG0gaXMgYSBjb21wdXRhdGlvbmFsIHBoYXJtYWNvcGhvcmUtYmFzZWQgYXBwcm9hY2ggdG8gaWRlbnRpZnkgY29nbmF0ZSByZWNlcHRvci1saWdhbmQgcGFpcnMgdGhhdCB3YXMgcmVjZW50bHkgdmFsaWRhdGVkIGluIGEgcGlsb3Qgc3R1ZHkgb24gYSBzbWFsbCBzZXQgb2YgSWdTRiBjb21wbGV4ZXMuIEFsdGhvdWdoIFByb3RMSUQgaGFzIHNob3duIGEgc3VjY2VzcyByYXRlIG9mIDYxJSBhdCBpZGVudGlmeWluZyBhdCBsZWFzdCBvbmUgY29nbmF0ZSBsaWdhbmQgZm9yIGEgZ2l2ZW4gcmVjZXB0b3IsIGl0IGN1cnJlbnRseSBsYWNrcyBhbnkgZm9ybSBvZiBjb25maWRlbmNlIG1lYXN1cmUgdGhhdCBjYW4gcHJpb3JpdGl6ZSBpbmRpdmlkdWFsIHJlY2VwdG9yLWxpZ2FuZCBwcmVkaWN0aW9ucyB0byBwdXJzdWUgZXhwZXJpbWVudGFsbHkuIEluIHRoaXMgc3R1ZHksIHdlIGV4cGFuZGVkIHRoZSBhcHBsaWNhdGlvbiBvZiBQcm90TElEIHRvIGNvdmVyIGFsbCBJZ1NGIGNvbXBsZXhlcyB3aXRoIGF2YWlsYWJsZSBzdHJ1Y3R1cmFsIGRhdGEuIEluIGFkZGl0aW9uLCB3ZSBpbnRyb2R1Y2VkIGFuIGFwcHJvYWNoIHRvIGVzdGltYXRlIHRoZSBjb25maWRlbmNlIG9mIHByZWRpY3Rpb25zIG1hZGUgYnkgUHJvdExJRCBiYXNlZCBvbiBhIHN0YXRpc3RpY2FsIGFuYWx5c2lzIG9mIGhvdyB0aGUgUHJvdExJRC1jb25zdHJ1Y3RlZCBwaGFybWFjb3Bob3JlIG1hdGNoZXMgdGhlIHN0cnVjdHVyZXMgb2YgY2FuZGlkYXRlIGxpZ2FuZHMuIFRoZSBjb25maWRlbmNlIHNjb3JlIGNvbWJpbmVzIHRoZSBwaHlzaWNvY2hlbWljYWwgY29tcGF0aWJpbGl0eSwgc3BhdGlhbCBjb25zaXN0ZW5jeSwgYW5kIG1hdGhlbWF0aWNhbCBza2V3bmVzcyBvZiB0aGUgZGlzdHJpYnV0aW9uIG9mIG1hdGNoZXMgdGhyb3VnaG91dCBhIHNldCBvZiBjYW5kaWRhdGUgbGlnYW5kcy4gT3VyIHJlc3VsdHMgc3VnZ2VzdCB0aGF0IGEgc3Vic2V0IG9mIGNhc2VzIG1lZXRpbmcgc3RyaW5nZW50IGNvbmZpZGVuY2UgY3JpdGVyaWEgd2lsbCBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgc3VjY2Vzc2Z1bCByZWNlcHRvci1saWdhbmQgcHJlZGljdGlvbi4gXCIsXG4gICAgICAgIGxpbms6IFwiaHR0cHM6Ly9wdWJtZWQubmNiaS5ubG0ubmloLmdvdi8zMzQ4Mzk5MS9cIixcbiAgICAgICAgdGh1bWJuYWlsOlwiXCIsXG4gICAgfVxuICAgIFxuICAgIFxuXVxuZXhwb3J0IGRlZmF1bHQgcHVibGljYXRpb25MaXN0Il0sIm5hbWVzIjpbInB1YmxpY2F0aW9uTGlzdCIsInllYXIiLCJ0aXRsZSIsImF1dGhvcnMiLCJhYnN0YXJjdCIsImxpbmsiLCJ0aHVtYm5haWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/publicationList.js\n");

/***/ })

});